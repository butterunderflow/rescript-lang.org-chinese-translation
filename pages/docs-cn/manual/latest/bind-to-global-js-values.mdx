---
title: "Bind to Global JS Values"
description: "JS interop with global JS values in ReScript"
canonical: "/docs/manual/latest/bind-to-global-js-values"
---

# 绑定全局 JS Values

**首先**，确保您要创建的value在[provided API](api/js)中不存在。

Some JS values, like `setTimeout`, live in the global scope. You can bind to them like so:
一些全局作用域（global scope）中的JS values，如`setTimeout`，您可以像这样去绑定它们：

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
@val external setTimeout: (unit => unit, int) => float = "setTimeout"
@val external clearTimeout: float => unit = "clearTimeout"
```
```js
// Empty output
```

</CodeTab>

([Js.Global](api/js/global) 模块已经提供了`setTimeout`, `clearTimeout` 及一些相关的绑定).

以上的代码绑定了JavaScript中的[`setTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrworkerGlobalScope/setTimeout)方法以及其对应的方法 [`clearTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout)。其中的 `external` 类型注解（type annotation）对 `setTimeout` 进行了描述：

- 它接收一个接收并返回 `unit` 的函数作为其第一个参数（在JavaScript中，被接收的函数会转化为一个不接受任何参数并无返回值（即 `undefined` ）的函数）
- 并且会接收一个整数（`int`）作为其第二个参数
- 它返回一个数字作为timeoutId。由于这个数字可能会很大，因此我们没有选择32位的int作为该数字的类型，而是选择使用float类型。

### 小建议

**上面的代码并不理想** 虽然我们可以看到 `setTimeout` 会返回一个 `float` 类型的返回值，并且 `clearTimeout` 会接收它。但是，这里并不能保证它一定会将 `setTimeout` 创建的float类型的返回值传递给 `clearTimeout`。就一些已知情况而言，一些人可能会把 `Math.random()` 传给 `clearTimeout` 。

ReScript是一门具有强大类型系统的语言！因此，让我们来使用一个流行的特性来解决这个问题：抽象类型（abstract types）。

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
type timerId
@val external setTimeout: (unit => unit, int) => timerId = "setTimeout"
@val external clearTimeout: timerId => unit = "clearTimeout"

let id = setTimeout(() => Js.log("hello"), 100)
clearTimeout(id)
```
```js
var id = setTimeout(function (param) {
  console.log("hello");
}, 100);

clearTimeout(id);
```

</CodeTab>

如上所示，`timerId` 是一个只会被 `setTimeout` 返回的类型！因此，不论这个数字是什么，我们现在都可以保证 `clearTimeout` _一定会_ 接收到一个有效的timeoutId。

`external` 是內联的，因此我们最终会得到与手写的代码一样可读的JavaScript代码。

## Global Modules

If you want to bind to a value inside a global module, e.g. `Math.random`, attach a `scope` to your `val` external:

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
@scope("Math") @val external random: unit => float = "random"
let someNumber = random()
```
```js
var someNumber = Math.random();
```

</CodeTab>

you can bind to an arbitrarily deep object by passing a tuple to `scope`:

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
@val @scope(("window", "location", "ancestorOrigins"))
external length: int = "length"
```
```js
// Empty output
```

</CodeTab>

This binds to `window.location.ancestorOrigins.length`.

## Special Global Values

Global values like `__filename` and `__DEV__` don't always exist; you can't even model them as an `option`, since the mere act of referring to them in ReScript (then compiled into JS) would trigger the usual `Uncaught ReferenceError: __filename is not defined` error in e.g. the browser environment.

For these troublesome global values, ReScript provides a special approach: `%external(a_single_identifier)`.

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
switch %external(__DEV__) {
| Some(_) => Js.log("dev mode")
| None => Js.log("production mode")
}
```
```js
var match = typeof __DEV__ === "undefined" ? undefined : __DEV__;

if (match !== undefined) {
  console.log("dev mode");
} else {
  console.log("production mode");
}
```

</CodeTab>

That first line's `typeof` check won't trigger a JS ReferenceError.

Another example:

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
switch %external(__filename) {
| Some(f) => Js.log(f)
| None => Js.log("non-node environment")
};
```
```js
var match = typeof (__filename) === "undefined" ? undefined : (__filename);

if (match !== undefined) {
  console.log(match);
} else {
  console.log("non-node environment");
}
```

</CodeTab>

<!-- TODO: revamp this page. Not good. Tell to use globalThis["foo"], and look in our stdlib -->
